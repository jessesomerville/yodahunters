// Package pg provides functionality for interacting with the postgres db.
package pg

import (
	"context"
	"fmt"
	"regexp"

	"github.com/jackc/pgx/v5"
	"github.com/jessesomerville/yodahunters/internal/envconfig"
	"github.com/jessesomerville/yodahunters/internal/log"
)

// Client is a postgres client for interacting with a postgres server.
type Client struct {
	conn *pgx.Conn
}

// NewClient initializes a new Client connected to the named DB.
//
// The provided dbname is used in the connection string generated by
// [ConnString]. If dbname is empty, the default user is used instead.
//
// Resources should be released by calling Close on the client.
func NewClient(ctx context.Context, dbname string) (*Client, error) {
	cs := ConnString(dbname)
	log.Infof(ctx, "Creating new client using %q", redactPassword(cs))
	conn, err := pgx.Connect(ctx, ConnString(dbname))
	if err == nil {
		err = conn.Ping(ctx)
	}
	if err != nil {
		return nil, fmt.Errorf("%w: %v", ErrConnection, err)
	}
	return &Client{conn}, nil
}

// Close closes the connection to the database.
// After calling Close on a client, subsequent calls to Close are a no-op.
func (c *Client) Close(ctx context.Context) error {
	return c.conn.Close(ctx)
}

// Query executes a query and returns the resulting rows.
//
// Queries can use parameter values which are referenced in the query string
// as $1, $2, etc. Parameters can only be used to substitute data values, not
// identifiers such as table or column names.
func (c *Client) Query(ctx context.Context, sql string, params ...any) (pgx.Rows, error) {
	if err := c.healthCheck(ctx); err != nil {
		return nil, err
	}
	return c.conn.Query(ctx, sql, params...)
}

// QueryRow executes a query and returns the resulting row.
//
// Queries can use parameter values which are referenced in the query string
// as $1, $2, etc. Parameters can only be used to substitute data values, not
// identifiers such as table or column names.
func (c *Client) QueryRow(ctx context.Context, sql string, params ...any) (pgx.Row) {
	return c.conn.QueryRow(ctx, sql, params...)
}

// Exec executes sql and returns the status of the operation.
//
// To execute a prepared statement, set sql to the name of the prepared
// statement to execute. See [Client.Query] for information on parameter
// substitution.
func (c *Client) Exec(ctx context.Context, sql string, params ...any) error {
	if err := c.healthCheck(ctx); err != nil {
		return err
	}
	_, err := c.conn.Exec(ctx, sql, params...)
	return err
}

// healthy checks the health of the client's connection.
func (c *Client) healthCheck(ctx context.Context) error {
	if c.conn.IsClosed() {
		return ErrClientClosed
	}
	if err := c.conn.Ping(ctx); err != nil {
		return fmt.Errorf("%w: %v", ErrConnection, err)
	}
	return nil
}

// ConnString returns a keyword/value connection string for the server.
//
// https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING
func ConnString(dbname string) string {
	host := envconfig.GetEnvOrDefault("YODAHUNTERS_DATABASE_HOST", "localhost")
	port := envconfig.GetEnvOrDefault("YODAHUNTERS_DATABASE_PORT", "5432")
	user := envconfig.GetEnvOrDefault("YODAHUNTERS_DATABASE_USER", "postgres")
	pass := envconfig.GetEnvOrDefault("YODAHUNTERS_DATABASE_PASSWORD", "")

	if dbname == "" {
		dbname = user
	}
	return fmt.Sprintf("host='%s' port=%s dbname='%s' user='%s' password='%s'", host, port, dbname, user, pass)
}

var pwRegexp = regexp.MustCompile(`password='[^']*'`)

func redactPassword(s string) string {
	return pwRegexp.ReplaceAllLiteralString(s, "password=hunter2")
}
